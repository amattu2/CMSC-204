	 @Override
	   public java.util.ArrayList<String> shortestPath(Town sourceVertex, Town destinationVertex)
	   {
	       dijkstraShortestPath(sourceVertex);
	      
	       java.util.ArrayList<String> sp = new java.util.ArrayList<String>();
	       java.util.LinkedList<Town> listOfTowns = destinationVertex.paths;
	      
	       for(int i = 0; i < listOfTowns.size(); i++)
	       {
	           sp.add(listOfTowns.get(i).toString());                  
	       }
	       sp.add(destinationVertex.toString());
	      
	       return sp;
	   }

	   @Override
	   public void dijkstraShortestPath(Town sourceVertex)
	   {
	       sourceVertex.distance = 0;
	       java.util.Set<Town> setOfTowns1 = new java.util.HashSet<>();
	       java.util.Set<Town> setOfTowns2 = new java.util.HashSet<>();
	       setOfTowns2.add(sourceVertex);

	       while(setOfTowns2.size() != 0)
	       {
	           Town currentTown = getLowestDistanceTown(setOfTowns2);
	           setOfTowns2.remove(currentTown);
	          
	           for(java.util.Map.Entry<Town, Integer> entry : currentTown.towns.entrySet())
	           {
	               Town adjTown = entry.getKey();
	               Integer edgeWeight = entry.getValue();
	              
	               if(!setOfTowns1.contains(adjTown))
	               {
	                   findMinDistance(adjTown, edgeWeight, currentTown);
	                   setOfTowns2.add(adjTown);
	               }
	           }
	           setOfTowns1.add(currentTown);
	       }
	   }

	   private static Town getLowestDistanceTown(java.util.Set<Town> setOfTowns)
	   {
	       Town lowDistanceTown = null;
	       int lowDistance = Integer.MAX_VALUE;
	       for(Town town : setOfTowns)
	       {
	           int townDistance = town.distance;
	           if(townDistance < lowDistance)
	           {
	               lowDistance = townDistance;
	               lowDistanceTown = town;
	           }
	       }
	       return lowDistanceTown;
	   }

	   private static void findMinDistance(Town evaluationTown, Integer edgeWeigh, Town sourceTown)
	   {
	       Integer sourceTownDistance = sourceTown.distance;
	       if(sourceTownDistance + edgeWeigh < evaluationTown.distance)
	       {
	           evaluationTown.distance = sourceTownDistance + edgeWeigh;
	           java.util.LinkedList<Town> sp = new java.util.LinkedList<>(sourceTown.paths);
	           sp.add(sourceTown);
	           evaluationTown.paths = sp;
	       }
	   }