	/**
	 * Find Shortest Path Between Two Towns
	 * 
	 * @param Town source
	 * @param Town destination
	 * @return ArrayList<String> paths
	 * @throws None
	 */
	@Override
	public java.util.ArrayList<String> shortestPath(Town s, Town d) {
		// Variables
		this.dijkstraShortestPath(s);
		java.util.ArrayList<String> result = new java.util.ArrayList<String>();
		java.util.LinkedList<Town> paths = d.paths;
		paths.add(d);
		
		// Loops
		for (Town t : paths) {
			String r = this.getPathDescription(s, t);
			
			System.out.println(r);
			
			result.add(r);
		}
		
		// Return
		return result;
	}
	
	/**
	 * Calculate Shortest Distance Between Source And Everything Else
	 * 
	 * @param Town source
	 * @return None
	 * @throws None
	 */
	@Override
	public void dijkstraShortestPath(Town s) {
		// Variables
		java.util.Set<Town> checked = new java.util.HashSet<Town>();
		java.util.Set<Town> unchecked = new java.util.HashSet<Town>();
		
		// Add Vertexes to Graph
		for (Town t : this.towns) {
			t.distance = Integer.MAX_VALUE;
			t.previous = null;
			t.via = null;
			unchecked.add(t);
		}
		
		// Add source (All variables reset above)
		this.getVertex(s).distance = 0;
		
		// Loop through unchecked
		while (unchecked.isEmpty() == false) {
			Town u = this.getMinimumDistance()
		}
		
	}
	